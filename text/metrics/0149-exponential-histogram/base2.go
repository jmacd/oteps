// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// histogram is of the prototypes for OTEP 149.  The Go implementation
// was copied from the Java prototype during review of
// https://github.com/open-telemetry/opentelemetry-proto/pull/322.
// The table of constants are generated by the program in ./generate.
package histogram

import (
	"math"
)

const (
	// mantissaWidth is the size of an IEEE 754 double-precision
	// floating-point mantissa.
	mantissaWidth = 52
	// exponentWidth is the size of an IEEE 754 double-precision
	// floating-point exponent.
	exponentWidth = 11

	// mantissaOnes is mantissaWidth 1 bits
	mantissaOnes = 1<<mantissaWidth - 1

	// exponentBias is the exponent bias specified for encoding
	// the IEEE 754 double-precision floating point exponent.
	exponentBias = 1<<(exponentWidth-1) - 1

	// exponentMask are set to 1 for the bits of an IEEE 754
	// floating point exponent (as distinct from the mantissa and
	// sign.
	exponentMask = ((1 << exponentWidth) - 1) << mantissaWidth
)

type (
	Base2HistogramMapper interface {
		MapToIndex(value float64) int64
		LowerBoundary(index int64) float64
		UpperBoundary(index int64) float64
	}

	LookupTableMapping struct {
		// there are 2^scale buckets for the mantissa to map to.
		scale int
		// An array of indices (lookup table). Mantissas of floats are mapped to this array
		// of equidistant buckets, which points to a bucket in the boundaries array
		// that is no further away than two buckets from the correct target bucket.
		indices []int64
		// the array of boundaries, represented as the mantissas of the double values in bits.
		boundaries []uint64
	}

	LogarithmMapping struct {
	}
)

var (
	_ Base2HistogramMapper = &LookupTableMapping{}
	_ LogarithmMapping     = &LogarithmMapping{}
)

func NewLookupTableMapping(scale int) *LookupTableMapping {
	if scale < 0 {
		// TODO: This logic does not work at negative scale
		// factors.  No calculated arrays are needed for
		// negative scales because the IEEE representation's
		// exponent maps directly to an index in that case.
		panic("unsupported scale")
	}

	bounds := calculateBoundaries(scale)
	indices := calculateIndices(bounds, scale)

	mapping := &LookupTableMapping{
		scale:      scale,
		indices:    indices,
		boundaries: bounds,
	}
	return mapping
}

// calculate boundaries for the mantissa part only.
// This calculates the bucket boundaries independent of the exponent.
// This mapping is the same for all mantissas, independent of the exponents.
// It depends only on the desired number of buckets subdividing the [1, 2] range covered by the mantissa.
// The number of buckets is 2^scale
func calculateBoundaries(scale int) []uint64 {
	size := 1 << scale

	if len(exponentialConstants) < size {
		// See the code in ./printer to precompute larger constant arrays.
		panic("precomputed boundaries are not available")
	}

	// Note: boundaries is two longer than size to ensure the
	// `mantissa >= el.boundaries[i+1]` test below is correct.
	boundaries := make([]uint64, size+2)
	factor := len(exponentialConstants) / size

	for i := 0; i < size; i++ {
		boundaries[i] = exponentialConstants[i*factor]
	}

	boundaries[size] = 1 << mantissaWidth
	boundaries[size+1] = 1 << mantissaWidth

	return boundaries
}

// Create the array which is roughly mapping into the boundaries array
func calculateIndices(boundaries []uint64, scale int) []int64 {
	length := 1 << scale
	indices := make([]int64, length)
	c := int64(0)
	for i := 0; i < length; i++ {
		// e.g. for scale = 2, this evaluates to:
		// i=0: 1.0; i=1: 1.25; i=2: 1.5; i=3: 1.75
		mantissaLowerBound := uint64(i) << (mantissaWidth - scale)
		// find the lowest boundary that is smaller than or equal to the equidistant bucket bound
		for boundaries[c+1] <= mantissaLowerBound {
			c++
		}
		indices[i] = c
	}
	return indices
}

// This is the code that actually maps the double value to the correct bin.
func (lt *LookupTableMapping) MapToIndex(value float64) int64 {
	valueBits := math.Float64bits(value)

	// The last 52 bits (bits 0 through 51) of a double are the mantissa.
	// Get these from the valueBits, which is a bit representation of the double value
	mantissa := mantissaOnes & valueBits

	// The bits 52 through 63 are the exponent.
	// extract the exponent from the bit representation of the double value.
	// Then shift it over by 52 bits (the length of the mantissa) and convert it to an integer
	// This also removes the sign bit.
	exponent := int64((exponentMask & valueBits) >> mantissaWidth)
	exponent -= exponentBias

	// find the "rough" bucket index from the indices array
	// The indices array has evenly spaced buckets and contains indices into the boundaries array
	// The line below transforms the normalized mantissa into an index into the indices array
	// Then, the index into the boundaries array is retrieved.
	rough := lt.indices[int(mantissa>>(mantissaWidth-lt.scale))]

	// The index in the boundaries array might not be correct
	// right away, there might be an offset of a maximum of two
	// buckets.  Therefore, look at three buckets: The one
	// specified by the index, and the next two.
	offset := rough
	if mantissa >= lt.boundaries[rough+1] {
		offset++
	}
	if mantissa >= lt.boundaries[rough+2] {
		offset++
	}

	// the indexOffset is only used to skip subnormal buckets
	// the exponent is used to find the correct "top-level" bucket,
	// and k is used to find the correct index therein.
	return (exponent << lt.scale) + offset
}

// upperBoundary is exclusive in this implementation, thus we define
// it as the lowerBoundary of the next bucket.
func (lt *LookupTableMapping) UpperBoundary(index int64) float64 {
	return lt.LowerBoundary(index + 1)
}

// lowerBoundary computes the inclusive lower bound corresponding to a
// particular histogram bucket.  This returns the least result value that
// such that `MapToIndex(lowerBoundary(index)) == index`.
func (lt *LookupTableMapping) LowerBoundary(index int64) float64 {
	length := int64(1 << lt.scale)
	exponent := index / length
	position := index % length
	if position < 0 {
		position += length
		exponent -= 1
	}
	mantissa := lt.boundaries[position] & mantissaOnes
	expo := uint64((int64(exponent+exponentBias) << mantissaWidth))
	return math.Float64frombits(expo | mantissa)
}

func NewLogarithmMapping(scale int) *LogarithmMapping {
	return &LogarithmMapping{}
}

func (l *LogarithmMapping) MapToIndex(value float64) int64 {
	return 0
}

func (l *LogarithmMapping) LowerBoundary(index int64) float64 {
	return 0
}

func (l *LogarithmMapping) UpperBoundary(index int64) float64 {
	return 0
}
